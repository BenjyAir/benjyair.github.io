<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>KokerWang‘s bloggg</title>
    <link href="http://www.kokerwang.com/rss.xml" rel="self"/>
    <link href="http://www.kokerwang.com/"/>
    <updated>2014-12-04T20:04:35+08:00</updated>
    <id>http://www.kokerwang.com</id>
    <author>
        <name>kokerwang</name>
        <email>kokerwang@gmail.com</email>
    </author>

    
    <entry>
        <title>从Framework层看Android启动</title>
        <link href="http://www.kokerwang.com/android/%E4%BB%8EFramework%E5%B1%82%E7%9C%8BAndroid%E5%90%AF%E5%8A%A8.html"/>
        <updated>2014-12-04T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/从Framework层看Android启动</id>
        <content type="html">&lt;hr /&gt;

&lt;h2&gt;序：&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;众所周知，Linux中所有的进程都是有init进程创建并运行的，Android系统基于Linux内核，所以也存在着init进程。
init进程启动的过程比较复杂，但是在准备工作做好之后，会通过jni创建Dalvik虚拟机，然后启动Android的核心Zygote进程，这个进程将成为所有应用进程的孵化器存在。下面我通过几个图来说明这个过程。&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Init进程启动以及Zygote启动&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181105.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是启动Android设备之后的进程，可以明显看到在init进程启动之后启动了Zygote进程，而Zygote作为之后的大部分进程的父进程存在。&lt;/p&gt;

&lt;h2&gt;Zygote启动应用程序&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181056.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是Zygote进程启动应用程序的流程图，Zygote进程调用fork（）函数创建出Zygote‘子进程，子进程共享父进程的代码区和链接信息，但是注意，新的Android应用程序并非通过fork（）来重新装载已有的进程代码区，而是动态的加载到复制出的Dalvik虚拟机上，而后，Zygote`进程将执行流程交给应用程序，Android应用程序开始运行，新生的应用程序拥有Zygote的进程库和资源的链接信息，所以运行速度很快。&lt;/p&gt;

&lt;h2&gt;Android Framework的启动过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181100.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是Android Framework的启动过程，Zygote启动Dalvik虚拟机后，会在生成一个Dalvik虚拟机示例，以便运行名称为SystemServer的java服务，SystemServer用于运行Audio Flinger与Surface Flinger本地服务，运行完本地服务之后开始运行Android Framework的java服务，也就是我们在Android系统架构图中Application Framework中的各种Manager Server
下图我们从代码层看Android Framework 的启动过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181052.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Binder IPC 机制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181047.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于Android应用程序与系统服务不在同一个系统进程中，这里就引入的Binder IPC 机制，服务使用者调用foo（）服务代理函数，而后foo（）服务代理函数通过Binder RPC调用Foo服务的foo（）服务Stub函数&lt;/p&gt;

&lt;p&gt;首先服务使用者调用foo（）代理函数，传递Binder RPC数据，该数据包含引用Foo服务的请求。Binder RPC数据经过Marshalling处理后，由Service Framework生成Binder IPC数据，然后通过Binder Driver 传递给Service Server端&lt;/p&gt;

&lt;p&gt;Service Server端收到Binder IPC 数据后，由 Service Framework对数据进行UnMarshalling处理，然后传递给Service Stub的onTransact（）函数，Service Stub根据Binder IPC数据中的RPC代码判断它是一个针对Foo服务的foo（）服务Stub函数的Binder RPC，最后， 以Binder IPC数据中包含的Binder RPC数据为参数，调用foo（）服务的Stub函数。至此，就是Binder IPC 的整个流程。&lt;/p&gt;

&lt;p&gt;————摘自《Android框架揭秘》 以上部分是这本书中的大部分知识的总结，其中的这几幅图更是这些重点简单明了的描述。当然Binder 机制只看图还是不能深入了解的，因为内容比较多，所以还是推荐看书，写的不错。&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;h2&gt;序：&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;众所周知，Linux中所有的进程都是有init进程创建并运行的，Android系统基于Linux内核，所以也存在着init进程。
init进程启动的过程比较复杂，但是在准备工作做好之后，会通过jni创建Dalvik虚拟机，然后启动Android的核心Zygote进程，这个进程将成为所有应用进程的孵化器存在。下面我通过几个图来说明这个过程。&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Init进程启动以及Zygote启动&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181105.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是启动Android设备之后的进程，可以明显看到在init进程启动之后启动了Zygote进程，而Zygote作为之后的大部分进程的父进程存在。&lt;/p&gt;

&lt;h2&gt;Zygote启动应用程序&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181056.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是Zygote进程启动应用程序的流程图，Zygote进程调用fork（）函数创建出Zygote‘子进程，子进程共享父进程的代码区和链接信息，但是注意，新的Android应用程序并非通过fork（）来重新装载已有的进程代码区，而是动态的加载到复制出的Dalvik虚拟机上，而后，Zygote`进程将执行流程交给应用程序，Android应用程序开始运行，新生的应用程序拥有Zygote的进程库和资源的链接信息，所以运行速度很快。&lt;/p&gt;

&lt;h2&gt;Android Framework的启动过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181100.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是Android Framework的启动过程，Zygote启动Dalvik虚拟机后，会在生成一个Dalvik虚拟机示例，以便运行名称为SystemServer的java服务，SystemServer用于运行Audio Flinger与Surface Flinger本地服务，运行完本地服务之后开始运行Android Framework的java服务，也就是我们在Android系统架构图中Application Framework中的各种Manager Server
下图我们从代码层看Android Framework 的启动过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181052.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Binder IPC 机制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141204181047.jpg&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于Android应用程序与系统服务不在同一个系统进程中，这里就引入的Binder IPC 机制，服务使用者调用foo（）服务代理函数，而后foo（）服务代理函数通过Binder RPC调用Foo服务的foo（）服务Stub函数&lt;/p&gt;

&lt;p&gt;首先服务使用者调用foo（）代理函数，传递Binder RPC数据，该数据包含引用Foo服务的请求。Binder RPC数据经过Marshalling处理后，由Service Framework生成Binder IPC数据，然后通过Binder Driver 传递给Service Server端&lt;/p&gt;

&lt;p&gt;Service Server端收到Binder IPC 数据后，由 Service Framework对数据进行UnMarshalling处理，然后传递给Service Stub的onTransact（）函数，Service Stub根据Binder IPC数据中的RPC代码判断它是一个针对Foo服务的foo（）服务Stub函数的Binder RPC，最后， 以Binder IPC数据中包含的Binder RPC数据为参数，调用foo（）服务的Stub函数。至此，就是Binder IPC 的整个流程。&lt;/p&gt;

&lt;p&gt;————摘自《Android框架揭秘》 以上部分是这本书中的大部分知识的总结，其中的这几幅图更是这些重点简单明了的描述。当然Binder 机制只看图还是不能深入了解的，因为内容比较多，所以还是推荐看书，写的不错。&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>关于WebView因url重定向而导致无法goBack的问题</title>
        <link href="http://www.kokerwang.com/android/%E5%85%B3%E4%BA%8EWebView%E5%9B%A0url%E9%87%8D%E5%AE%9A%E5%90%91%E8%80%8C%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95goBack%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
        <updated>2014-11-16T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/关于WebView因url重定向而导致无法goBack的问题</id>
        <content type="html">&lt;hr /&gt;

&lt;p&gt;最近项目中有一些界面需要嵌入wap页，在按返回键的时候让WebView goBack, 大部分界面都是可以正常回退的,可是某些会重定向的地址却无法正常goBack,原因是,退回重定向之前的url又被重定向了回来,网上的解决办法是自己控制一个url集合,我试了一下非常麻烦,因为我们还需要goForward 功能,仅仅使用一个LinkedList还满足不了需求.最终还是放弃了这样的做法,后来终于在&lt;code&gt;stackOverflow&lt;/code&gt; 上找到了解决的办法,解决的方法真是格外的简单.直接看代码&lt;/p&gt;

&lt;p&gt;为了让WebView控制界面里面的url跳转,我们一般都会设置&lt;code&gt;WebViewClient&lt;/code&gt; ，并重写shouldOverrideUrlLoading方法，让webView加载点击url,一般的例子代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;webView.setWebViewClient(new WebViewClient() {

    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
         view.loadUrl(url);
        return true;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决办法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;webView.setWebViewClient(new WebViewClient() {

    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {

        return false;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;万万没想到解决办法就在 api 里面,shouldOverrideUrlLoading这个方法的 api 如下:&lt;/p&gt;

&lt;p&gt;Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView. If WebViewClient is not provided, by default WebView will ask Activity Manager to choose the proper handler for the url. If WebViewClient is provided, return true means the host application handles the url, while return false means the current WebView handles the url.&lt;/p&gt;

&lt;p&gt;就是说如果application处理这个url则返回&lt;code&gt;true&lt;/code&gt;,如果WebView处理这个url则返回&lt;code&gt;false&lt;/code&gt;.我们让WebView处理了这个url就应该返回&lt;code&gt;false&lt;/code&gt;,否则相当于处理的两(多)次,而这也是这个问题出现的原因所在.&lt;/p&gt;

&lt;p&gt;后来我又看了一下&lt;code&gt;WebViewClient&lt;/code&gt;的其他方法发现原来好多问题都可以在这里解决,只是之前用的不多不知道有这些方法,例如:&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;onPageStarted 在页面加载开始时调用.&lt;/li&gt;
&lt;li&gt;onPageFinished 在页面加载结束时调用.&lt;/li&gt;
&lt;li&gt;onLoadResource 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你还需要更丰富的处理效果那么推荐你用&lt;code&gt;WebChromeClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;ps: 最近国内github好不稳定啊，大家还是翻墙吧.&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;p&gt;最近项目中有一些界面需要嵌入wap页，在按返回键的时候让WebView goBack, 大部分界面都是可以正常回退的,可是某些会重定向的地址却无法正常goBack,原因是,退回重定向之前的url又被重定向了回来,网上的解决办法是自己控制一个url集合,我试了一下非常麻烦,因为我们还需要goForward 功能,仅仅使用一个LinkedList还满足不了需求.最终还是放弃了这样的做法,后来终于在&lt;code&gt;stackOverflow&lt;/code&gt; 上找到了解决的办法,解决的方法真是格外的简单.直接看代码&lt;/p&gt;

&lt;p&gt;为了让WebView控制界面里面的url跳转,我们一般都会设置&lt;code&gt;WebViewClient&lt;/code&gt; ，并重写shouldOverrideUrlLoading方法，让webView加载点击url,一般的例子代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;webView.setWebViewClient(new WebViewClient() {

    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
         view.loadUrl(url);
        return true;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决办法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;webView.setWebViewClient(new WebViewClient() {

    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {

        return false;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;万万没想到解决办法就在 api 里面,shouldOverrideUrlLoading这个方法的 api 如下:&lt;/p&gt;

&lt;p&gt;Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView. If WebViewClient is not provided, by default WebView will ask Activity Manager to choose the proper handler for the url. If WebViewClient is provided, return true means the host application handles the url, while return false means the current WebView handles the url.&lt;/p&gt;

&lt;p&gt;就是说如果application处理这个url则返回&lt;code&gt;true&lt;/code&gt;,如果WebView处理这个url则返回&lt;code&gt;false&lt;/code&gt;.我们让WebView处理了这个url就应该返回&lt;code&gt;false&lt;/code&gt;,否则相当于处理的两(多)次,而这也是这个问题出现的原因所在.&lt;/p&gt;

&lt;p&gt;后来我又看了一下&lt;code&gt;WebViewClient&lt;/code&gt;的其他方法发现原来好多问题都可以在这里解决,只是之前用的不多不知道有这些方法,例如:&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;onPageStarted 在页面加载开始时调用.&lt;/li&gt;
&lt;li&gt;onPageFinished 在页面加载结束时调用.&lt;/li&gt;
&lt;li&gt;onLoadResource 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你还需要更丰富的处理效果那么推荐你用&lt;code&gt;WebChromeClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;ps: 最近国内github好不稳定啊，大家还是翻墙吧.&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>Android应用内存溢出导致应用退出的解决方案</title>
        <link href="http://www.kokerwang.com/android/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E5%BA%94%E7%94%A8%E9%80%80%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
        <updated>2014-11-11T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/Android应用内存溢出导致应用退出的解决方案</id>
        <content type="html">&lt;hr /&gt;

&lt;p&gt;昨天项目里遇到了一个严重问题,用户在使用一段时间应用之后,便会非常慢,最终导致内存溢出而崩溃,这个问题几乎让我们的一切努力白费.我几乎花了一整天的时间才终于找到了问题所在.问题的原因让我完全意料不到.&lt;/p&gt;

&lt;p&gt;在分析原因的时候我使用的是 Eclipse 的 Memory AnalysisTools + DDMS,这套工具真是在关键时候救了我一命.
附上Memory Analysis插件的&lt;a href=&quot;http://www.eclipse.org/mat/downloads.php&quot;&gt;下载地址&lt;/a&gt;
只使用DDMS也可以看出在activity切换过程中的内存变化,但是不能并发现问题的具体所在,所以我们需要MAT(&lt;code&gt;Memory AnalysisTools&lt;/code&gt;)来分析具体是那个类引发的问题.上图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141111211142.png&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图大家应该都看的懂吧,不懂的我简单说一下,也不要嫌弃我啰嗦:&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;1位置是开始监控 一般在启动应用之后就可以点上来查看记录了&lt;/li&gt;
&lt;li&gt;2位置是保存分析到文件,装了Memory Analysis之后便可以直接打开分析界面&lt;/li&gt;
&lt;li&gt;3位置是查看内存数值的区域，内存变化的过程基本上就是在这里分析出来的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体的使用大家可以参考这篇文章&lt;a href=&quot;http://www.360doc.com/content/12/1023/14/203871_243274421.shtml&quot;&gt;http://www.360doc.com/content/12/1023/14/203871_243274421.shtml&lt;/a&gt;,解决问题的过程真的是非常的快乐的,我希望大家也可以通过这个过程get新技能,而不是一味的copy.&lt;/p&gt;

&lt;p&gt;分析的过程我也就不多说了 好多次的分析才找到了问题所在,依然直接说结果:&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在大家在写app的时候通常会使用一个集合来保存整个activity.或放在BaseActivity里,或放在Application里,
然后在退出应用的时候遍历集合逐个调用finish方法,以此来达到退出整个应用,这些方法在网上很多写法,也是大多数人推荐的做法,但我如今碰到的问题就是这里导致的.我的测试结果是,虽然在每个activity的finish方法里把自己从容器里移除自己,但依然因为这个导致activity不能释放,如此循环往复导致了内存溢出.找到了问题所在就好解决多了,就怕有问题自己也摸不到头绪.其实如果自己控制好每个界面的启动和销毁,这样的做法完全是多此一举的,如果你实在想这样做,推荐的是使用广播的方法,在每个activity里面注册一个广播,应用退出的时候通过广播来关闭所有activity,不要忘了在onDestroy里注销广播哟,&lt;/p&gt;

&lt;p&gt;ps:
我曾经也深信不疑的使用网上的各种现成的代码,但如今,我想至少应该测试过会再使用才行,不要人云亦云,知其然知其所以然,才能最大的提升自己的能力.感谢项目经理的耐心教导。
另外&lt;strong&gt;MAT&lt;/strong&gt;工具推荐大家都学习一下,特别是大型项目一定要严格控制内存,否则会死的很惨.&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;p&gt;昨天项目里遇到了一个严重问题,用户在使用一段时间应用之后,便会非常慢,最终导致内存溢出而崩溃,这个问题几乎让我们的一切努力白费.我几乎花了一整天的时间才终于找到了问题所在.问题的原因让我完全意料不到.&lt;/p&gt;

&lt;p&gt;在分析原因的时候我使用的是 Eclipse 的 Memory AnalysisTools + DDMS,这套工具真是在关键时候救了我一命.
附上Memory Analysis插件的&lt;a href=&quot;http://www.eclipse.org/mat/downloads.php&quot;&gt;下载地址&lt;/a&gt;
只使用DDMS也可以看出在activity切换过程中的内存变化,但是不能并发现问题的具体所在,所以我们需要MAT(&lt;code&gt;Memory AnalysisTools&lt;/code&gt;)来分析具体是那个类引发的问题.上图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20141111211142.png&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图大家应该都看的懂吧,不懂的我简单说一下,也不要嫌弃我啰嗦:&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;1位置是开始监控 一般在启动应用之后就可以点上来查看记录了&lt;/li&gt;
&lt;li&gt;2位置是保存分析到文件,装了Memory Analysis之后便可以直接打开分析界面&lt;/li&gt;
&lt;li&gt;3位置是查看内存数值的区域，内存变化的过程基本上就是在这里分析出来的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体的使用大家可以参考这篇文章&lt;a href=&quot;http://www.360doc.com/content/12/1023/14/203871_243274421.shtml&quot;&gt;http://www.360doc.com/content/12/1023/14/203871_243274421.shtml&lt;/a&gt;,解决问题的过程真的是非常的快乐的,我希望大家也可以通过这个过程get新技能,而不是一味的copy.&lt;/p&gt;

&lt;p&gt;分析的过程我也就不多说了 好多次的分析才找到了问题所在,依然直接说结果:&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在大家在写app的时候通常会使用一个集合来保存整个activity.或放在BaseActivity里,或放在Application里,
然后在退出应用的时候遍历集合逐个调用finish方法,以此来达到退出整个应用,这些方法在网上很多写法,也是大多数人推荐的做法,但我如今碰到的问题就是这里导致的.我的测试结果是,虽然在每个activity的finish方法里把自己从容器里移除自己,但依然因为这个导致activity不能释放,如此循环往复导致了内存溢出.找到了问题所在就好解决多了,就怕有问题自己也摸不到头绪.其实如果自己控制好每个界面的启动和销毁,这样的做法完全是多此一举的,如果你实在想这样做,推荐的是使用广播的方法,在每个activity里面注册一个广播,应用退出的时候通过广播来关闭所有activity,不要忘了在onDestroy里注销广播哟,&lt;/p&gt;

&lt;p&gt;ps:
我曾经也深信不疑的使用网上的各种现成的代码,但如今,我想至少应该测试过会再使用才行,不要人云亦云,知其然知其所以然,才能最大的提升自己的能力.感谢项目经理的耐心教导。
另外&lt;strong&gt;MAT&lt;/strong&gt;工具推荐大家都学习一下,特别是大型项目一定要严格控制内存,否则会死的很惨.&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>关于使用commons-codec.jar出现方法找不到的问题</title>
        <link href="http://www.kokerwang.com/android/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8commons-codec.jar%E5%87%BA%E7%8E%B0%E6%96%B9%E6%B3%95%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
        <updated>2014-11-02T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/关于使用commons-codec.jar出现方法找不到的问题</id>
        <content type="html">&lt;hr /&gt;

&lt;h2&gt;起因&lt;/h2&gt;

&lt;p&gt;最近项目里要做非即时一对一消息功能,图省事我就直接用了友盟提供的sdk,接收直接用友盟提供的android的sdk,发送方使用友盟服务端java api,一个挺简单的功能,理论是可以行得通的,实践证明也是可以行得通的,只是中途出现一个很坑的问题让我不得不记录下来.&lt;/p&gt;

&lt;h2&gt;经过&lt;/h2&gt;

&lt;p&gt;事情是这样的,在我使用发送消息的api 的时候需要获得validationToken,而这个值是appkey + appMasterSecret + 时间戳 经过DigestUtils.md5Hex 算法得来的,而md5Hex这个方法在使用的时候竟然找不到,我看了一下在android.jar 文件里面只有声明却没有实现,这可苦了我了.于是乎我找来了commons-codec-1.6.jar心想这就可以了吧,结果又出了包名重复的错,这下难办了,我又不能修改android.jar.咋办呢,只能拿commons-codec的源码改包名了.果然,问题解决.&lt;/p&gt;

&lt;h2&gt;结果&lt;/h2&gt;

&lt;p&gt;写的很简单,可当时却足足花了我半天的时间才解决,如果你也碰到了这样的问题,直接下源码改包名便可轻松解决,包我就不传了,网上很多.顺便支持一下友盟,真的很方便!!&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;h2&gt;起因&lt;/h2&gt;

&lt;p&gt;最近项目里要做非即时一对一消息功能,图省事我就直接用了友盟提供的sdk,接收直接用友盟提供的android的sdk,发送方使用友盟服务端java api,一个挺简单的功能,理论是可以行得通的,实践证明也是可以行得通的,只是中途出现一个很坑的问题让我不得不记录下来.&lt;/p&gt;

&lt;h2&gt;经过&lt;/h2&gt;

&lt;p&gt;事情是这样的,在我使用发送消息的api 的时候需要获得validationToken,而这个值是appkey + appMasterSecret + 时间戳 经过DigestUtils.md5Hex 算法得来的,而md5Hex这个方法在使用的时候竟然找不到,我看了一下在android.jar 文件里面只有声明却没有实现,这可苦了我了.于是乎我找来了commons-codec-1.6.jar心想这就可以了吧,结果又出了包名重复的错,这下难办了,我又不能修改android.jar.咋办呢,只能拿commons-codec的源码改包名了.果然,问题解决.&lt;/p&gt;

&lt;h2&gt;结果&lt;/h2&gt;

&lt;p&gt;写的很简单,可当时却足足花了我半天的时间才解决,如果你也碰到了这样的问题,直接下源码改包名便可轻松解决,包我就不传了,网上很多.顺便支持一下友盟,真的很方便!!&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>下拉刷新封装</title>
        <link href="http://www.kokerwang.com/android/%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%B0%81%E8%A3%85.html"/>
        <updated>2014-10-21T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/下拉刷新封装</id>
        <content type="html">&lt;hr /&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt; 忙了两周,楼里app终于完成了,25号正式上线,顺便吐槽一下接私活果然好坑,特别是这种工期比较着急的,不过今天款项下来了,拿到money之后感觉整个人萌萌哒~~ 废话不多说,今天分享一下自己在工作中对&lt;a href=&quot;https://github.com/chrisbanes/Android-PullToRefresh&quot;&gt;Android-PullToRefresh&lt;/a&gt;的封装&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;目前Android上实现下拉刷新的方式主要有两种:&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;通过修改HeaderView的Padding实现,常见作法是使用自定义组件继承ListView,一个类就可以搞定&lt;/li&gt;
&lt;li&gt;在listview底部套一层ScrollView或者LinearLayout,通过移动ListView来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一种方法简单但是碰到复杂的ListView,特别是带有图片的的item就会特别卡,因为主线程刷新界面也需要时间,而改变之后的效果只有刷新之后才能看到,所以给人的感觉是一顿一顿的.第二种方法就不会出现这样的效果,这里推荐的是Android-PullToRefresh,具体使用大家可以看该项目的demo,该项目对常见的带滑动的组件都有支持,很强大,而且可以定制.&lt;/p&gt;

&lt;h2&gt;使用&lt;/h2&gt;

&lt;p&gt;我的封装主要是对消息处理的封装和页码计算的封装,使你只用写自己逻辑而不用管这些细节
直接看代码, 首先是封装类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.louli.activity.louli;

import java.text.SimpleDateFormat;
import java.util.List;
import android.app.Activity;
import android.os.Message;
import android.widget.BaseAdapter;
import android.widget.ListView;
import android.widget.Toast;

import com.handmark.pulltorefresh.library.PullToRefreshBase;
import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener2;
import com.handmark.pulltorefresh.library.PullToRefreshListView;
import com.louli.community.R;

/**
 * 带下拉刷新的activity 需要继承该类
 * 
 * @author KokerWang
 * 
 */
public abstract class ListViewBaseActivity extends Activity {

    /**
     * 分页的页码，当前第几页
     */
    public int pageCount = 1;

    /**
     * 当前刷新状态　　-1　下拉　,　1　　上拉 , 0 默认值
     */
    public int status;

    /**
     * 获取页码   如果界面里有1个以上的 PullToRefreshListView组件需要重重写 pageCount的get set 方法,自己记录页码
     * 
     * @return
     */
    public int getPageCount() {
        return pageCount;
    }

    /**
     * 设置页码  如果界面里有1个以上的 PullToRefreshListView组件需要重重写 pageCount的get set 方法,自己记录页码
     * 
     * @param pageCount
     */
    public void setPageCount(int pageCount) {
        this.pageCount = pageCount;
    }

    /**
     * 返回数据内容的集合
     * 
     * @return
     */
    public abstract List&amp;lt;?&amp;gt; getList();

    /**
     * 返回ListView
     * 
     * @return
     */
    public abstract PullToRefreshListView getListView();

    /**
     * 返回适配器
     * 
     * @return
     */
    public abstract BaseAdapter getAdapter();

    /**
     * 该方法主要完成异步获取数据分别需要处理三种结果 获取成功 msg.what=LOAD_SUCCESS 获取失败
     * msg.what=LOAD_FAIL 没有数据 msg.what=LOAD_NODATA 获取成功的数据放在msg.obj 里 ，List 类型
     */
    public abstract void loadData();

    /**
     * 初始化带刷新的ListView
     * 
     * @param id
     *            组件id
     * @return
     */
    protected PullToRefreshListView initListView(int id) {
        PullToRefreshListView listView = (PullToRefreshListView) findViewById(id);
        if (listView == null) {
            return null;
        }
        return initListView(listView);
    }

    /**
     * 初始化带刷新的ListView
     * 
     * @param listView
     *            帅新组件
     * @return
     */
    protected PullToRefreshListView initListView(PullToRefreshListView listView) {
        if (listView == null) {
            return null;
        }
        listView.setMode(Mode.BOTH);
        //以下为自定义提示语 可以不写使用默认的
        listView.getLoadingLayoutProxy(false, true).setPullLabel(getResources().getString(R.string.push_label));
        listView.getLoadingLayoutProxy(false, true).setRefreshingLabel(getResources().getString(R.string.refreshing_label));
        listView.getLoadingLayoutProxy(false, true).setReleaseLabel(getResources().getString(R.string.release_label));
        listView.getLoadingLayoutProxy(true, false).setPullLabel(getResources().getString(R.string.pull_label));
        listView.getLoadingLayoutProxy(true, false).setRefreshingLabel(getResources().getString(R.string.refreshing_label));
        listView.getLoadingLayoutProxy(true, false).setReleaseLabel(getResources().getString(R.string.release_label));

        listView.setOnRefreshListener(new OnRefreshListener2Impl());
        return listView;
    }

    /**
     * 获取成功的处理, 主要在handler 里面调用
     * 
     * @param msg
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    protected void loadSucess(Message msg) {
        List ls = (List) msg.obj;
        if (getPageCount() == 1) {
            getList().clear();
            getListView().setMode(Mode.BOTH);
        }
        if (ls != null) {
            getList().addAll(ls);
        }
        getAdapter().notifyDataSetChanged();
        getListView().onRefreshComplete();
    };

    /**
     * 获取成功但是没有数据的处理, 主要在handler 里面调用
     * 
     * @param msg
     */
    protected void loadZeroDate(Message msg) {
        if (getPageCount() == 1) {
            Toast.makeText(this, R.string.zero_date, Toast.LENGTH_SHORT).show();

        } else {
            Toast.makeText(this, R.string.msg_last, Toast.LENGTH_SHORT).show();
        }
        getAdapter().notifyDataSetChanged();
        getListView().onRefreshComplete();
        getListView().setMode(Mode.PULL_FROM_START);
    };

    /**
     * 获取失败的处理, 主要在handler 里面调用
     * 
     * @param msg
     */
    protected void loadFalt(Message msg) {
        Toast.makeText(this, R.string.load_error, Toast.LENGTH_SHORT).show();
        getAdapter().notifyDataSetChanged();
        getListView().onRefreshComplete();
    };

    /**
     * 上拉刷新及加载更多的回调接口实现类
     * 
     * @author tom
     * 
     */
    private class OnRefreshListener2Impl implements OnRefreshListener2&amp;lt;ListView&amp;gt; {
        SimpleDateFormat sdf = new SimpleDateFormat(getResources().getString(R.string.refresh_for) + &quot;:MM-dd hh:mm&quot;);

        @Override
        public void onPullDownToRefresh(PullToRefreshBase&amp;lt;ListView&amp;gt; refreshView) {
            //下拉
            status = 1;
            setPageCount(1);
            loadData();
            String label = sdf.format(System.currentTimeMillis());
            refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);
        }

        @Override
        public void onPullUpToRefresh(PullToRefreshBase&amp;lt;ListView&amp;gt; refreshView) {
            //上拉
            status = -1;
            setPageCount(getPageCount() + 1);
            loadData();
            String label = sdf.format(System.currentTimeMillis());
            refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的界面里有一个以上的PullToRefreshListView组件,那你需要额外重写getPageCount和setPageCount来自己控制页码,当然这个时候其他几个重写的方法也需要你加上判断,具体示例我会在文章最后附上&lt;/p&gt;

&lt;p&gt;下面看例子代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;package com.test;

import android.os.Message;


public class ChannelExhibitionListActivity extends ListViewBaseActivity {

    // 界面组件
    PullToRefreshListView _listView;
    List&amp;lt;ChannelExhibitionListItem&amp;gt; _list;
    ChannelExhibitionListAdapter _adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.channel_exhibition_list_activity);
        init();
    }

    private void init() {
        // 初始化组件及适配器
        _listView = initListView(R.id.listView);
        // 获取内部listview 推荐这样用而不是直接给_listview设置参数
        ListView actualListView = _listView.getRefreshableView();
        _adapter = new ChannelExhibitionListAdapter(this);
        _list = new ArrayList&amp;lt;ChannelExhibitionListItem&amp;gt;();
        _adapter.setList(_list);
        actualListView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {
                // 不要忘了这一行代码　　因为自带了headview 所以postiton加了1 这里要减去
                position--;
            }
        });
        actualListView.setAdapter(_adapter);

    }

    // 异步任务接受处理
    Handler _handler = new Handler() {
        public void handleMessage(android.os.Message msg) {
            switch (msg.what) {
            case LOAD_SUCCESS:
                loadSucess(msg);
                break;
            case LOAD_FAIL:
                loadFalt(msg);
                break;
            case LOAD_NODATA:
                loadZeroDate(msg);
                break;
            }
        }
    };

    // 获取数据的线程
    Thread loadThread;

    /**
     * 更改数据并刷新adapter
     */
    @Override
    public void loadData() {
        createCountryThread();
        loadThread.start();
    }

    /**
     * 初始化线程
     */
    private void createCountryThread() {
        loadThread = new Thread(new Runnable() {

            @Override
            public void run() {
                List&amp;lt;ChannelExhibitionListItem&amp;gt; channels = new ArrayList&amp;lt;ChannelExhibitionListItem&amp;gt;();
                try {
                    // 把页码拼接到url
                    StringBuffer loadService = new StringBuffer(); 
                    loadService.append(&quot;?r=findlist&amp;amp;pagesize=15&amp;amp;pagenow=&quot; + getPageCount());

                    String res = HttpConstants.getPHPRequest(&quot;url&quot;, loadService.toString());
                    if (res == null || res.equals(&quot;&quot;)) {
                        throw new Exception(&quot;resoult=&quot; + res);
                    }
                    JSONObject resultJsonObject = new JSONObject(res);
                    int code = resultJsonObject.getInt(&quot;returncode&quot;);
                    if (code == 0) {
                        // 业务处理　　大概就是解析出list
                        JSONArray datas = resultJsonObject.getJSONArray(&quot;result&quot;);
                        if (datas.length() == 0) {
                            Message m = _handler.obtainMessage(LOAD_NODATA);
                            _handler.sendMessage(m);
                            return;
                        }
                        int size = datas.length();
                        for (int i = 0; i &amp;lt; size; i++) {
                            JSONObject obj = (JSONObject) datas.get(i);
                            ChannelExhibitionListItem item = new ChannelExhibitionListItem();
                            item.setId(&quot;&quot;);

                            channels.add(item);
                        }
                        Message message = _handler.obtainMessage(LOAD_SUCCESS);
                        message.obj = channels;
                        _handler.sendMessage(message);
                        return;
                    }else if(code == 1){
                        Message m = _handler.obtainMessage(LOAD_NODATA);
                        _handler.sendMessage(m);
                        return;
                    }
                    // 获取失败
                    Message m = _handler.obtainMessage(LOAD_FAIL);
                    _handler.sendMessage(m);
                } catch (Exception e) {
                    Message m = _handler.obtainMessage(LOAD_FAIL);
                    _handler.sendMessage(m);
                } finally {
                    //关闭进度条
                    //Util.dismissWaitingDialog(pd);
                }
            }
        });
    }

    @Override
    public List&amp;lt;?&amp;gt; getList() {
        return _list;
    }

    @Override
    public PullToRefreshListView getListView() {
        return _listView;
    }

    @Override
    public BaseAdapter getAdapter() {
        return _adapter;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码只是逻辑代码,复制在自己的项目中是不能运行的,参考着就可以写了,因为我们的项目是使用的httpClient+Handler回调,所以用这个特别方便, 如果你们项目使用Volley 那就更简单了,稍微修改一下就能用&lt;/p&gt;

&lt;p&gt;最后是布局  布局只需要把ListView替换实现就可以 其他的一下属性和ListView通用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;  &amp;lt;com.handmark.pulltorefresh.library.PullToRefreshListView
        android:id=&quot;@+id/listView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:cacheColorHint=&quot;#00000000&quot;
        android:divider=&quot;#19000000&quot;
        android:dividerHeight=&quot;1dp&quot;
        android:fadingEdge=&quot;none&quot;
        android:fastScrollEnabled=&quot;false&quot;
        android:footerDividersEnabled=&quot;true&quot;
        android:headerDividersEnabled=&quot;true&quot;
        android:smoothScrollbar=&quot;true&quot; &amp;gt;
    &amp;lt;/com.handmark.pulltorefresh.library.PullToRefreshListView&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;附&lt;/h2&gt;

&lt;p&gt;多个PullToRefreshListView组件时的示例代码 , 其他几个重写的方法也要这样修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 *当前第几个PullToRefreshListView的标示
 */
int num=1;
/**
 * 页码
 */
private int count_p = 1;
private int count_r = 1;


/**
 * 获取页码
 * 
 * @return
 */
public int getPageCount() {
    if (num ==1) {
        return count_p;
    }else{
        return count_r;
    }
}

/**
 * 设置页码
 * 
 * @param pageCount
 */
public void setPageCount(int pageCount) {
    if (num ==1) {
        this.count_p = pageCount;
    }else{
        this.count_r = pageCount;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写完啦 ,我要去腐败喽&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt; 忙了两周,楼里app终于完成了,25号正式上线,顺便吐槽一下接私活果然好坑,特别是这种工期比较着急的,不过今天款项下来了,拿到money之后感觉整个人萌萌哒~~ 废话不多说,今天分享一下自己在工作中对&lt;a href=&quot;https://github.com/chrisbanes/Android-PullToRefresh&quot;&gt;Android-PullToRefresh&lt;/a&gt;的封装&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;目前Android上实现下拉刷新的方式主要有两种:&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;通过修改HeaderView的Padding实现,常见作法是使用自定义组件继承ListView,一个类就可以搞定&lt;/li&gt;
&lt;li&gt;在listview底部套一层ScrollView或者LinearLayout,通过移动ListView来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一种方法简单但是碰到复杂的ListView,特别是带有图片的的item就会特别卡,因为主线程刷新界面也需要时间,而改变之后的效果只有刷新之后才能看到,所以给人的感觉是一顿一顿的.第二种方法就不会出现这样的效果,这里推荐的是Android-PullToRefresh,具体使用大家可以看该项目的demo,该项目对常见的带滑动的组件都有支持,很强大,而且可以定制.&lt;/p&gt;

&lt;h2&gt;使用&lt;/h2&gt;

&lt;p&gt;我的封装主要是对消息处理的封装和页码计算的封装,使你只用写自己逻辑而不用管这些细节
直接看代码, 首先是封装类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.louli.activity.louli;

import java.text.SimpleDateFormat;
import java.util.List;
import android.app.Activity;
import android.os.Message;
import android.widget.BaseAdapter;
import android.widget.ListView;
import android.widget.Toast;

import com.handmark.pulltorefresh.library.PullToRefreshBase;
import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener2;
import com.handmark.pulltorefresh.library.PullToRefreshListView;
import com.louli.community.R;

/**
 * 带下拉刷新的activity 需要继承该类
 * 
 * @author KokerWang
 * 
 */
public abstract class ListViewBaseActivity extends Activity {

    /**
     * 分页的页码，当前第几页
     */
    public int pageCount = 1;

    /**
     * 当前刷新状态　　-1　下拉　,　1　　上拉 , 0 默认值
     */
    public int status;

    /**
     * 获取页码   如果界面里有1个以上的 PullToRefreshListView组件需要重重写 pageCount的get set 方法,自己记录页码
     * 
     * @return
     */
    public int getPageCount() {
        return pageCount;
    }

    /**
     * 设置页码  如果界面里有1个以上的 PullToRefreshListView组件需要重重写 pageCount的get set 方法,自己记录页码
     * 
     * @param pageCount
     */
    public void setPageCount(int pageCount) {
        this.pageCount = pageCount;
    }

    /**
     * 返回数据内容的集合
     * 
     * @return
     */
    public abstract List&amp;lt;?&amp;gt; getList();

    /**
     * 返回ListView
     * 
     * @return
     */
    public abstract PullToRefreshListView getListView();

    /**
     * 返回适配器
     * 
     * @return
     */
    public abstract BaseAdapter getAdapter();

    /**
     * 该方法主要完成异步获取数据分别需要处理三种结果 获取成功 msg.what=LOAD_SUCCESS 获取失败
     * msg.what=LOAD_FAIL 没有数据 msg.what=LOAD_NODATA 获取成功的数据放在msg.obj 里 ，List 类型
     */
    public abstract void loadData();

    /**
     * 初始化带刷新的ListView
     * 
     * @param id
     *            组件id
     * @return
     */
    protected PullToRefreshListView initListView(int id) {
        PullToRefreshListView listView = (PullToRefreshListView) findViewById(id);
        if (listView == null) {
            return null;
        }
        return initListView(listView);
    }

    /**
     * 初始化带刷新的ListView
     * 
     * @param listView
     *            帅新组件
     * @return
     */
    protected PullToRefreshListView initListView(PullToRefreshListView listView) {
        if (listView == null) {
            return null;
        }
        listView.setMode(Mode.BOTH);
        //以下为自定义提示语 可以不写使用默认的
        listView.getLoadingLayoutProxy(false, true).setPullLabel(getResources().getString(R.string.push_label));
        listView.getLoadingLayoutProxy(false, true).setRefreshingLabel(getResources().getString(R.string.refreshing_label));
        listView.getLoadingLayoutProxy(false, true).setReleaseLabel(getResources().getString(R.string.release_label));
        listView.getLoadingLayoutProxy(true, false).setPullLabel(getResources().getString(R.string.pull_label));
        listView.getLoadingLayoutProxy(true, false).setRefreshingLabel(getResources().getString(R.string.refreshing_label));
        listView.getLoadingLayoutProxy(true, false).setReleaseLabel(getResources().getString(R.string.release_label));

        listView.setOnRefreshListener(new OnRefreshListener2Impl());
        return listView;
    }

    /**
     * 获取成功的处理, 主要在handler 里面调用
     * 
     * @param msg
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    protected void loadSucess(Message msg) {
        List ls = (List) msg.obj;
        if (getPageCount() == 1) {
            getList().clear();
            getListView().setMode(Mode.BOTH);
        }
        if (ls != null) {
            getList().addAll(ls);
        }
        getAdapter().notifyDataSetChanged();
        getListView().onRefreshComplete();
    };

    /**
     * 获取成功但是没有数据的处理, 主要在handler 里面调用
     * 
     * @param msg
     */
    protected void loadZeroDate(Message msg) {
        if (getPageCount() == 1) {
            Toast.makeText(this, R.string.zero_date, Toast.LENGTH_SHORT).show();

        } else {
            Toast.makeText(this, R.string.msg_last, Toast.LENGTH_SHORT).show();
        }
        getAdapter().notifyDataSetChanged();
        getListView().onRefreshComplete();
        getListView().setMode(Mode.PULL_FROM_START);
    };

    /**
     * 获取失败的处理, 主要在handler 里面调用
     * 
     * @param msg
     */
    protected void loadFalt(Message msg) {
        Toast.makeText(this, R.string.load_error, Toast.LENGTH_SHORT).show();
        getAdapter().notifyDataSetChanged();
        getListView().onRefreshComplete();
    };

    /**
     * 上拉刷新及加载更多的回调接口实现类
     * 
     * @author tom
     * 
     */
    private class OnRefreshListener2Impl implements OnRefreshListener2&amp;lt;ListView&amp;gt; {
        SimpleDateFormat sdf = new SimpleDateFormat(getResources().getString(R.string.refresh_for) + &quot;:MM-dd hh:mm&quot;);

        @Override
        public void onPullDownToRefresh(PullToRefreshBase&amp;lt;ListView&amp;gt; refreshView) {
            //下拉
            status = 1;
            setPageCount(1);
            loadData();
            String label = sdf.format(System.currentTimeMillis());
            refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);
        }

        @Override
        public void onPullUpToRefresh(PullToRefreshBase&amp;lt;ListView&amp;gt; refreshView) {
            //上拉
            status = -1;
            setPageCount(getPageCount() + 1);
            loadData();
            String label = sdf.format(System.currentTimeMillis());
            refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的界面里有一个以上的PullToRefreshListView组件,那你需要额外重写getPageCount和setPageCount来自己控制页码,当然这个时候其他几个重写的方法也需要你加上判断,具体示例我会在文章最后附上&lt;/p&gt;

&lt;p&gt;下面看例子代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;package com.test;

import android.os.Message;


public class ChannelExhibitionListActivity extends ListViewBaseActivity {

    // 界面组件
    PullToRefreshListView _listView;
    List&amp;lt;ChannelExhibitionListItem&amp;gt; _list;
    ChannelExhibitionListAdapter _adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.channel_exhibition_list_activity);
        init();
    }

    private void init() {
        // 初始化组件及适配器
        _listView = initListView(R.id.listView);
        // 获取内部listview 推荐这样用而不是直接给_listview设置参数
        ListView actualListView = _listView.getRefreshableView();
        _adapter = new ChannelExhibitionListAdapter(this);
        _list = new ArrayList&amp;lt;ChannelExhibitionListItem&amp;gt;();
        _adapter.setList(_list);
        actualListView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {
                // 不要忘了这一行代码　　因为自带了headview 所以postiton加了1 这里要减去
                position--;
            }
        });
        actualListView.setAdapter(_adapter);

    }

    // 异步任务接受处理
    Handler _handler = new Handler() {
        public void handleMessage(android.os.Message msg) {
            switch (msg.what) {
            case LOAD_SUCCESS:
                loadSucess(msg);
                break;
            case LOAD_FAIL:
                loadFalt(msg);
                break;
            case LOAD_NODATA:
                loadZeroDate(msg);
                break;
            }
        }
    };

    // 获取数据的线程
    Thread loadThread;

    /**
     * 更改数据并刷新adapter
     */
    @Override
    public void loadData() {
        createCountryThread();
        loadThread.start();
    }

    /**
     * 初始化线程
     */
    private void createCountryThread() {
        loadThread = new Thread(new Runnable() {

            @Override
            public void run() {
                List&amp;lt;ChannelExhibitionListItem&amp;gt; channels = new ArrayList&amp;lt;ChannelExhibitionListItem&amp;gt;();
                try {
                    // 把页码拼接到url
                    StringBuffer loadService = new StringBuffer(); 
                    loadService.append(&quot;?r=findlist&amp;amp;pagesize=15&amp;amp;pagenow=&quot; + getPageCount());

                    String res = HttpConstants.getPHPRequest(&quot;url&quot;, loadService.toString());
                    if (res == null || res.equals(&quot;&quot;)) {
                        throw new Exception(&quot;resoult=&quot; + res);
                    }
                    JSONObject resultJsonObject = new JSONObject(res);
                    int code = resultJsonObject.getInt(&quot;returncode&quot;);
                    if (code == 0) {
                        // 业务处理　　大概就是解析出list
                        JSONArray datas = resultJsonObject.getJSONArray(&quot;result&quot;);
                        if (datas.length() == 0) {
                            Message m = _handler.obtainMessage(LOAD_NODATA);
                            _handler.sendMessage(m);
                            return;
                        }
                        int size = datas.length();
                        for (int i = 0; i &amp;lt; size; i++) {
                            JSONObject obj = (JSONObject) datas.get(i);
                            ChannelExhibitionListItem item = new ChannelExhibitionListItem();
                            item.setId(&quot;&quot;);

                            channels.add(item);
                        }
                        Message message = _handler.obtainMessage(LOAD_SUCCESS);
                        message.obj = channels;
                        _handler.sendMessage(message);
                        return;
                    }else if(code == 1){
                        Message m = _handler.obtainMessage(LOAD_NODATA);
                        _handler.sendMessage(m);
                        return;
                    }
                    // 获取失败
                    Message m = _handler.obtainMessage(LOAD_FAIL);
                    _handler.sendMessage(m);
                } catch (Exception e) {
                    Message m = _handler.obtainMessage(LOAD_FAIL);
                    _handler.sendMessage(m);
                } finally {
                    //关闭进度条
                    //Util.dismissWaitingDialog(pd);
                }
            }
        });
    }

    @Override
    public List&amp;lt;?&amp;gt; getList() {
        return _list;
    }

    @Override
    public PullToRefreshListView getListView() {
        return _listView;
    }

    @Override
    public BaseAdapter getAdapter() {
        return _adapter;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码只是逻辑代码,复制在自己的项目中是不能运行的,参考着就可以写了,因为我们的项目是使用的httpClient+Handler回调,所以用这个特别方便, 如果你们项目使用Volley 那就更简单了,稍微修改一下就能用&lt;/p&gt;

&lt;p&gt;最后是布局  布局只需要把ListView替换实现就可以 其他的一下属性和ListView通用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;  &amp;lt;com.handmark.pulltorefresh.library.PullToRefreshListView
        android:id=&quot;@+id/listView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:cacheColorHint=&quot;#00000000&quot;
        android:divider=&quot;#19000000&quot;
        android:dividerHeight=&quot;1dp&quot;
        android:fadingEdge=&quot;none&quot;
        android:fastScrollEnabled=&quot;false&quot;
        android:footerDividersEnabled=&quot;true&quot;
        android:headerDividersEnabled=&quot;true&quot;
        android:smoothScrollbar=&quot;true&quot; &amp;gt;
    &amp;lt;/com.handmark.pulltorefresh.library.PullToRefreshListView&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;附&lt;/h2&gt;

&lt;p&gt;多个PullToRefreshListView组件时的示例代码 , 其他几个重写的方法也要这样修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 *当前第几个PullToRefreshListView的标示
 */
int num=1;
/**
 * 页码
 */
private int count_p = 1;
private int count_r = 1;


/**
 * 获取页码
 * 
 * @return
 */
public int getPageCount() {
    if (num ==1) {
        return count_p;
    }else{
        return count_r;
    }
}

/**
 * 设置页码
 * 
 * @param pageCount
 */
public void setPageCount(int pageCount) {
    if (num ==1) {
        this.count_p = pageCount;
    }else{
        this.count_r = pageCount;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写完啦 ,我要去腐败喽&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>Android简单实现圆形头像(续)</title>
        <link href="http://www.kokerwang.com/android/Android%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F(%E7%BB%AD).html"/>
        <updated>2014-10-11T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/Android简单实现圆形头像(续)</id>
        <content type="html">&lt;hr /&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;上一篇文章里面详细讲解了用自己的方式实现圆形头像，如今发现之前的代码效率并不高,因为每次都要createBitmap和转换图片,createBitmap是一件很费内存的事,而频繁转换是一件很费cpu的事,这样费手机资源肯定必然是不行的,并且随着自己对imageloader的深入使用,发现使用imageloader还有另外一种更简单的方法来实现这样的效果,或许能解决这样的问题.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面我详细介绍下,先看代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; DisplayImageOptions options = new DisplayImageOptions.Builder()
    .showImageForEmptyUri(R.drawable.default_image)
    .showImageOnFail(R.drawable.default_image)
    .imageScaleType(ImageScaleType.EXACTLY_STRETCHED)
    .bitmapConfig(Config.RGB_565)
    .cacheInMemory(true)
    .cacheOnDisk(true)
    .resetViewBeforeLoading(true)
    .displayer(new RoundedBitmapDisplayer(112)).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面的displayer方法可以接收实现BitmapDisplayer接口的对象,关键点就在这里,imageloader有默认的可以实现圆角的Displayer 那就是 FadeInBitmapDisplayer（int durationMillis）,durationMillis就是圆角的半径. 用他就不用之前自己那么麻烦的方法了.&lt;/p&gt;

&lt;h2&gt;完整代码&lt;/h2&gt;

&lt;p&gt;imageloader 的初始化方法没变，同上一篇blog,这里只展示一下显示的工具类.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//显示圆角的option
public static DisplayImageOptions options ;

public static &amp;lt;T extends ImageView&amp;gt; void displayImage2Circle(T container, String url) {
    if(options == null){
        options = new DisplayImageOptions.Builder()
            .showImageForEmptyUri(R.drawable.default_image)
            .showImageOnFail(R.drawable.default_image)
            .imageScaleType(ImageScaleType.EXACTLY_STRETCHED)
            .bitmapConfig(Config.RGB_565)
            .cacheInMemory(true)
            .cacheOnDisk(true)
            .resetViewBeforeLoading(true)
            // 我们的图片大小是70dp 所以我这里半径=70*1.6 ,其他情况可以自己算,或者动态设置
            .displayer(new RoundedBitmapDisplayer(112)) 
            .build();
    }
    ImageLoader.getInstance().displayImage(url, container, options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;附 :&lt;/h2&gt;

&lt;p&gt;其他displayer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;displayer：  
        RoundedBitmapDisplayer（int roundPixels）设置圆角图片  
        FakeBitmapDisplayer（）这个类什么都没做  
        FadeInBitmapDisplayer（int durationMillis）设置图片渐显的时间  
        SimpleBitmapDisplayer()正常显示一张图片
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;疑问&lt;/h2&gt;

&lt;p&gt;imageloader缓存的图片是转换之前的bitmap呢还是之后的呢?&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;如果是之前的,那执行效率并不会较之前我实现的方法提高多少,只是转换的工作交给了imageloader, 每次还是要转换.&lt;/li&gt;
&lt;li&gt;如果缓存的是转换之后的圆角bitmap 那效率就会大大提高,而我也希望是这样的,但这样拓展性可能会降低.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;等有时间了我会深入研究一下imageloader 的源码,把结果写出来&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;上一篇文章里面详细讲解了用自己的方式实现圆形头像，如今发现之前的代码效率并不高,因为每次都要createBitmap和转换图片,createBitmap是一件很费内存的事,而频繁转换是一件很费cpu的事,这样费手机资源肯定必然是不行的,并且随着自己对imageloader的深入使用,发现使用imageloader还有另外一种更简单的方法来实现这样的效果,或许能解决这样的问题.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面我详细介绍下,先看代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; DisplayImageOptions options = new DisplayImageOptions.Builder()
    .showImageForEmptyUri(R.drawable.default_image)
    .showImageOnFail(R.drawable.default_image)
    .imageScaleType(ImageScaleType.EXACTLY_STRETCHED)
    .bitmapConfig(Config.RGB_565)
    .cacheInMemory(true)
    .cacheOnDisk(true)
    .resetViewBeforeLoading(true)
    .displayer(new RoundedBitmapDisplayer(112)).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面的displayer方法可以接收实现BitmapDisplayer接口的对象,关键点就在这里,imageloader有默认的可以实现圆角的Displayer 那就是 FadeInBitmapDisplayer（int durationMillis）,durationMillis就是圆角的半径. 用他就不用之前自己那么麻烦的方法了.&lt;/p&gt;

&lt;h2&gt;完整代码&lt;/h2&gt;

&lt;p&gt;imageloader 的初始化方法没变，同上一篇blog,这里只展示一下显示的工具类.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//显示圆角的option
public static DisplayImageOptions options ;

public static &amp;lt;T extends ImageView&amp;gt; void displayImage2Circle(T container, String url) {
    if(options == null){
        options = new DisplayImageOptions.Builder()
            .showImageForEmptyUri(R.drawable.default_image)
            .showImageOnFail(R.drawable.default_image)
            .imageScaleType(ImageScaleType.EXACTLY_STRETCHED)
            .bitmapConfig(Config.RGB_565)
            .cacheInMemory(true)
            .cacheOnDisk(true)
            .resetViewBeforeLoading(true)
            // 我们的图片大小是70dp 所以我这里半径=70*1.6 ,其他情况可以自己算,或者动态设置
            .displayer(new RoundedBitmapDisplayer(112)) 
            .build();
    }
    ImageLoader.getInstance().displayImage(url, container, options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;附 :&lt;/h2&gt;

&lt;p&gt;其他displayer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;displayer：  
        RoundedBitmapDisplayer（int roundPixels）设置圆角图片  
        FakeBitmapDisplayer（）这个类什么都没做  
        FadeInBitmapDisplayer（int durationMillis）设置图片渐显的时间  
        SimpleBitmapDisplayer()正常显示一张图片
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;疑问&lt;/h2&gt;

&lt;p&gt;imageloader缓存的图片是转换之前的bitmap呢还是之后的呢?&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;如果是之前的,那执行效率并不会较之前我实现的方法提高多少,只是转换的工作交给了imageloader, 每次还是要转换.&lt;/li&gt;
&lt;li&gt;如果缓存的是转换之后的圆角bitmap 那效率就会大大提高,而我也希望是这样的,但这样拓展性可能会降低.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;等有时间了我会深入研究一下imageloader 的源码,把结果写出来&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>Android简单实现圆形头像</title>
        <link href="http://www.kokerwang.com/android/Android%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F.html"/>
        <updated>2014-09-30T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/Android简单实现圆形头像</id>
        <content type="html">&lt;hr /&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天项目中即时通信工具部分要把好友头像由方形转换成圆形,大概也是跟上时代的潮流吧,毕竟连qq都开始使用圆形头像了,我在这里记录一下修改过程.&lt;/p&gt;

&lt;p&gt;在网上找了一番之后,大概解决方法有两种&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;使用自定义组件继承ImageView&lt;/li&gt;
&lt;li&gt;通过对BitMap重绘得到&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一种方式,有许多开源框架可以实现,如&lt;a href=&quot;https://github.com/nostra13/Android-Universal-Image-Loader&quot;&gt;&lt;strong&gt;CircleImageView&lt;/strong&gt;&lt;/a&gt;&amp;nbsp;,由于我们项目中图片缓存及显示使用的是&lt;a href=&quot;https://github.com/nostra13/Android-Universal-Image-Loader&quot;&gt;&lt;strong&gt;Android-Universal-Image-Loader&lt;/strong&gt;&lt;/a&gt;,而他本身支持在获取到网络图片之后增加回调,那我毫无疑问的选择了第二种方式实现,&lt;/p&gt;

&lt;p&gt;首先是圆形图片转换的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 将图片转为圆型  不标准的图形从中心截取
 * 
 * @param bitmap
 * @return
 */
public static Bitmap getRoundedCornerBitmap(Bitmap bitmap) {
    int width = bitmap.getWidth();
    int height = bitmap.getHeight();
    Bitmap output = Bitmap.createBitmap(width, height, Config.ARGB_8888);
    Canvas canvas = new Canvas(output);
    // 切圆的直径
    int minLength = width &amp;gt; height ? height : width;
    final int color = 0xff424242;
    final Paint paint = new Paint();
    int x = (width - minLength) / 2;
    int y = (height - minLength) / 2;
    final Rect rect = new Rect(x, y, x + minLength, y + minLength);
    final RectF rectF = new RectF(rect);
    final float roundPx = minLength / 2;

    paint.setAntiAlias(true);
    canvas.drawARGB(0, 0, 0, 0);
    paint.setColor(color);
    canvas.drawRoundRect(rectF, roundPx, roundPx, paint);
    paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
    canvas.drawBitmap(bitmap, rect, rect, paint);
    return output;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后是显示图片工具类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static SimpleImageLoadingListener listener;

public static &amp;lt;T extends ImageView&amp;gt; void displayImage2Circle(T container, String url) {
    if (listener == null) {
        listener = new SimpleImageLoadingListener() {
            @Override
            public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {
                super.onLoadingComplete(imageUri, view, loadedImage);
                ((ImageView) view).setImageBitmap(getRoundedCornerBitmap(loadedImage));
            }
        };
    }
    ImageLoader.getInstance().displayImage(url, container, listener);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只要是需要把图片显示为圆形的地方直接调用&lt;code&gt;displayImage2Circle&lt;/code&gt;这个方法即可&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本以为已经大功告成,没想到使用之后却发现图片四周仿佛被切掉一部分一样,如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20140930151619.png&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;起先以为是图片有白边,后来发现不是,&lt;a href=&quot;http://img0.bdstatic.com/img/image/shouye/mxzyq-11795342220.jpg&quot;&gt;图片地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;然后又以为是半径没算对,验证之后再次被排除&lt;/li&gt;
&lt;li&gt;最终把原因定位到了Image-Loader上,解决办法如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ImageLoaderConfiguration的defaultDisplayImageOptions方法需要一个DisplayImageOptions参数而DisplayImageOptions的参数的imageScaleType属性默认的是ImageScaleType.IN_SAMPLE_POWER_OF_2就是这个属性导致的图片不圆,查了一下文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/** 
 * 图片的缩放方式 
 */  
imageScaleType(ImageScaleType imageScaleType)  
imageScaleType:  
    EXACTLY :图像将完全按比例缩小的目标大小  
    EXACTLY_STRETCHED:图片会完全缩放到目标大小  
    IN_SAMPLE_INT:图像将被二次采样,并且倍数为整数倍  
    IN_SAMPLE_POWER_OF_2:图片将降低2倍，直到下一减少步骤，使图像更小的目标大小  
    NONE:图片不会调整  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IN_SAMPLE_POWER_OF_2模式下缩放是成倍缩放的所以导致实际显示的要比我设定的宽一些,改成EXACTLY_STRETCHED之后问题得到解决&lt;/p&gt;

&lt;p&gt;最后展示一下最终效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20140930154619.png&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及Image-Loader的完整设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;private void initImageLoader() {
    DisplayImageOptions options = new DisplayImageOptions.Builder()
    .showImageForEmptyUri(R.drawable.default_image) 
    .showImageOnFail(R.drawable.default_image) 
    .imageScaleType(ImageScaleType.EXACTLY_STRETCHED) 
    .bitmapConfig(Config.RGB_565) 
    .cacheInMemory(true)
    .cacheOnDisk(true)
    .resetViewBeforeLoading(true)
    .build();

    File cacheDir = StorageUtils.getOwnCacheDirectory(getApplicationContext(), Util.getCachePath()); 

    ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(this)
    .denyCacheImageMultipleSizesInMemory()
    .memoryCache(new LruMemoryCache(2 * 1024 * 1024))
    .threadPoolSize(4)
    .memoryCacheSize(2 * 1024 * 1024)
    .diskCache(new UnlimitedDiscCache(cacheDir)) // 缓存路径
    .diskCacheSize(50 * 1024 * 1024)
    .diskCacheFileCount(100)
    .defaultDisplayImageOptions(options) 
    .build();

     ImageLoader.getInstance().init(config);  

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公司项目我就不放源码了,核心代码都在上面了.有问题可以和我联系&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天项目中即时通信工具部分要把好友头像由方形转换成圆形,大概也是跟上时代的潮流吧,毕竟连qq都开始使用圆形头像了,我在这里记录一下修改过程.&lt;/p&gt;

&lt;p&gt;在网上找了一番之后,大概解决方法有两种&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;使用自定义组件继承ImageView&lt;/li&gt;
&lt;li&gt;通过对BitMap重绘得到&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一种方式,有许多开源框架可以实现,如&lt;a href=&quot;https://github.com/nostra13/Android-Universal-Image-Loader&quot;&gt;&lt;strong&gt;CircleImageView&lt;/strong&gt;&lt;/a&gt;&amp;nbsp;,由于我们项目中图片缓存及显示使用的是&lt;a href=&quot;https://github.com/nostra13/Android-Universal-Image-Loader&quot;&gt;&lt;strong&gt;Android-Universal-Image-Loader&lt;/strong&gt;&lt;/a&gt;,而他本身支持在获取到网络图片之后增加回调,那我毫无疑问的选择了第二种方式实现,&lt;/p&gt;

&lt;p&gt;首先是圆形图片转换的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 将图片转为圆型  不标准的图形从中心截取
 * 
 * @param bitmap
 * @return
 */
public static Bitmap getRoundedCornerBitmap(Bitmap bitmap) {
    int width = bitmap.getWidth();
    int height = bitmap.getHeight();
    Bitmap output = Bitmap.createBitmap(width, height, Config.ARGB_8888);
    Canvas canvas = new Canvas(output);
    // 切圆的直径
    int minLength = width &amp;gt; height ? height : width;
    final int color = 0xff424242;
    final Paint paint = new Paint();
    int x = (width - minLength) / 2;
    int y = (height - minLength) / 2;
    final Rect rect = new Rect(x, y, x + minLength, y + minLength);
    final RectF rectF = new RectF(rect);
    final float roundPx = minLength / 2;

    paint.setAntiAlias(true);
    canvas.drawARGB(0, 0, 0, 0);
    paint.setColor(color);
    canvas.drawRoundRect(rectF, roundPx, roundPx, paint);
    paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
    canvas.drawBitmap(bitmap, rect, rect, paint);
    return output;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后是显示图片工具类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static SimpleImageLoadingListener listener;

public static &amp;lt;T extends ImageView&amp;gt; void displayImage2Circle(T container, String url) {
    if (listener == null) {
        listener = new SimpleImageLoadingListener() {
            @Override
            public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {
                super.onLoadingComplete(imageUri, view, loadedImage);
                ((ImageView) view).setImageBitmap(getRoundedCornerBitmap(loadedImage));
            }
        };
    }
    ImageLoader.getInstance().displayImage(url, container, listener);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只要是需要把图片显示为圆形的地方直接调用&lt;code&gt;displayImage2Circle&lt;/code&gt;这个方法即可&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本以为已经大功告成,没想到使用之后却发现图片四周仿佛被切掉一部分一样,如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20140930151619.png&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;起先以为是图片有白边,后来发现不是,&lt;a href=&quot;http://img0.bdstatic.com/img/image/shouye/mxzyq-11795342220.jpg&quot;&gt;图片地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;然后又以为是半径没算对,验证之后再次被排除&lt;/li&gt;
&lt;li&gt;最终把原因定位到了Image-Loader上,解决办法如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ImageLoaderConfiguration的defaultDisplayImageOptions方法需要一个DisplayImageOptions参数而DisplayImageOptions的参数的imageScaleType属性默认的是ImageScaleType.IN_SAMPLE_POWER_OF_2就是这个属性导致的图片不圆,查了一下文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/** 
 * 图片的缩放方式 
 */  
imageScaleType(ImageScaleType imageScaleType)  
imageScaleType:  
    EXACTLY :图像将完全按比例缩小的目标大小  
    EXACTLY_STRETCHED:图片会完全缩放到目标大小  
    IN_SAMPLE_INT:图像将被二次采样,并且倍数为整数倍  
    IN_SAMPLE_POWER_OF_2:图片将降低2倍，直到下一减少步骤，使图像更小的目标大小  
    NONE:图片不会调整  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IN_SAMPLE_POWER_OF_2模式下缩放是成倍缩放的所以导致实际显示的要比我设定的宽一些,改成EXACTLY_STRETCHED之后问题得到解决&lt;/p&gt;

&lt;p&gt;最后展示一下最终效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/20140930154619.png&quot; alt=&quot;tool-editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及Image-Loader的完整设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;private void initImageLoader() {
    DisplayImageOptions options = new DisplayImageOptions.Builder()
    .showImageForEmptyUri(R.drawable.default_image) 
    .showImageOnFail(R.drawable.default_image) 
    .imageScaleType(ImageScaleType.EXACTLY_STRETCHED) 
    .bitmapConfig(Config.RGB_565) 
    .cacheInMemory(true)
    .cacheOnDisk(true)
    .resetViewBeforeLoading(true)
    .build();

    File cacheDir = StorageUtils.getOwnCacheDirectory(getApplicationContext(), Util.getCachePath()); 

    ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(this)
    .denyCacheImageMultipleSizesInMemory()
    .memoryCache(new LruMemoryCache(2 * 1024 * 1024))
    .threadPoolSize(4)
    .memoryCacheSize(2 * 1024 * 1024)
    .diskCache(new UnlimitedDiscCache(cacheDir)) // 缓存路径
    .diskCacheSize(50 * 1024 * 1024)
    .diskCacheFileCount(100)
    .defaultDisplayImageOptions(options) 
    .build();

     ImageLoader.getInstance().init(config);  

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公司项目我就不放源码了,核心代码都在上面了.有问题可以和我联系&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>Android BroadcastReceiver 接收顺序</title>
        <link href="http://www.kokerwang.com/android/Android%20BroadcastReceiver%20%E6%8E%A5%E6%94%B6%E9%A1%BA%E5%BA%8F.html"/>
        <updated>2014-09-28T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/android/Android BroadcastReceiver 接收顺序</id>
        <content type="html">&lt;hr /&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天项目里有这样一个需求，访问一个请求并把手机号作为参数传过去，同时拦截收到的短信验证码，自动填进EditText，一个看似很简单的功能。然而在真机上测试竟然没有拦截到，把优先级调到最大也无济于事。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;四处寻访，原来BroadcastReceiver除了有优先级顺序之外，还有注册的顺序。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大家都知道广播分有序广播和无序广播，有序广播和无序广播的区别就是，有序广播可以被任何一个接受者消耗掉，而无序广播则不可以，注册的话既可以在代码里面动态注册，也可以在Manifest里面直接声明，屌丝青年大多会直接在Manifest里面定义注册，文艺青年一般使用代码动态注册。这两种方式接受的广播的顺序是不一样的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般来说有序广播在同等优先级的情况下有这样的顺序&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;动态注册的BroadcastReceiver，先注册的先接收&lt;/li&gt;
&lt;li&gt;Manifest里注册的BroadcastReceiver，接收广播的顺序与String[] java.io.File.list()顺序一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在不同优先级的情况下&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;有序广播按优先级顺序接收&lt;/li&gt;
&lt;li&gt;无序广播因为是异步的所以接收broadcast的顺序不确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 假设有如下优先级的5个接收器  并且B先于C注册     &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; 1.动态A（优先级=1）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 2.动态B（优先级=2）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 3.动态C（优先级=2）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 4.静态D（优先级=1)       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 5.静态E（优先级=2）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 那么实际接收顺序应为：  B C E A D  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;hr /&gt;

&lt;h2&gt;关于 String[] java.io.File.list()&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们以开机时候发出的广播android.intent.action.BOOT_COMPLETED为例，这是个无序广播。如果应用想要开启自启动，那么就要监听这个广播，程序启动之前，动态广播接收器肯定是无法使用的，只能在XML中静态注册。大家都知道，第三方应用是存放在/data/app目录下，当安装完毕之后，你会找到一个文件，他的名字是以与安装的应用包名开始的，然后可能会跟着&quot;-数字.apk&quot;，比如：com.android.test-1.apk。接收的顺序与这个名字是有关的！那么关系是怎样的呢？&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;系统在开机的时候，会按着一个顺序解析apk，首先，会解析手机中的/system/framework这个目录，原生系统中，这下面就一个apk - framework-res.apk，当然各个厂商也会加入自己的内容&lt;/li&gt;
&lt;li&gt;然后受到重视的文件夹按顺序分别为：
/system/app，
/vendor/app，
/data/app，
/drm/app-private
那么每个文件夹下解析的顺序是怎样的呢？我们先只看/data/app，也就是用户安装的第三方应用的存放位置，这与下面代码返回结果的顺序是一致的
File file = new File(&quot;/data/app/&quot;);
String[] files = file.list();
也就是说，我们按顺序打印这个数组，就能知道哪个接收器会先接收到这个广播，哪个会后接收到&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天项目里有这样一个需求，访问一个请求并把手机号作为参数传过去，同时拦截收到的短信验证码，自动填进EditText，一个看似很简单的功能。然而在真机上测试竟然没有拦截到，把优先级调到最大也无济于事。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;四处寻访，原来BroadcastReceiver除了有优先级顺序之外，还有注册的顺序。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大家都知道广播分有序广播和无序广播，有序广播和无序广播的区别就是，有序广播可以被任何一个接受者消耗掉，而无序广播则不可以，注册的话既可以在代码里面动态注册，也可以在Manifest里面直接声明，屌丝青年大多会直接在Manifest里面定义注册，文艺青年一般使用代码动态注册。这两种方式接受的广播的顺序是不一样的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般来说有序广播在同等优先级的情况下有这样的顺序&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;动态注册的BroadcastReceiver，先注册的先接收&lt;/li&gt;
&lt;li&gt;Manifest里注册的BroadcastReceiver，接收广播的顺序与String[] java.io.File.list()顺序一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在不同优先级的情况下&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;有序广播按优先级顺序接收&lt;/li&gt;
&lt;li&gt;无序广播因为是异步的所以接收broadcast的顺序不确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 假设有如下优先级的5个接收器  并且B先于C注册     &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; 1.动态A（优先级=1）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 2.动态B（优先级=2）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 3.动态C（优先级=2）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 4.静态D（优先级=1)       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 5.静态E（优先级=2）      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 那么实际接收顺序应为：  B C E A D  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;hr /&gt;

&lt;h2&gt;关于 String[] java.io.File.list()&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们以开机时候发出的广播android.intent.action.BOOT_COMPLETED为例，这是个无序广播。如果应用想要开启自启动，那么就要监听这个广播，程序启动之前，动态广播接收器肯定是无法使用的，只能在XML中静态注册。大家都知道，第三方应用是存放在/data/app目录下，当安装完毕之后，你会找到一个文件，他的名字是以与安装的应用包名开始的，然后可能会跟着&quot;-数字.apk&quot;，比如：com.android.test-1.apk。接收的顺序与这个名字是有关的！那么关系是怎样的呢？&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;系统在开机的时候，会按着一个顺序解析apk，首先，会解析手机中的/system/framework这个目录，原生系统中，这下面就一个apk - framework-res.apk，当然各个厂商也会加入自己的内容&lt;/li&gt;
&lt;li&gt;然后受到重视的文件夹按顺序分别为：
/system/app，
/vendor/app，
/data/app，
/drm/app-private
那么每个文件夹下解析的顺序是怎样的呢？我们先只看/data/app，也就是用户安装的第三方应用的存放位置，这与下面代码返回结果的顺序是一致的
File file = new File(&quot;/data/app/&quot;);
String[] files = file.list();
也就是说，我们按顺序打印这个数组，就能知道哪个接收器会先接收到这个广播，哪个会后接收到&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</summary>
    </entry>
    
    <entry>
        <title>My first blog</title>
        <link href="http://www.kokerwang.com/others/My%20first%20blog.html"/>
        <updated>2014-09-27T00:00:00+08:00</updated>
        <id>http://www.kokerwang.com/others/My first blog</id>
        <content type="html">&lt;hr /&gt;

&lt;h2&gt;历程&lt;/h2&gt;

&lt;p&gt;一直以来我都是只写笔记不写博客，总以为写博客很无聊。直到后来接触到了github，接触到了开源，我才发现了分享的乐趣，我想我的那些笔记一定也不喜欢孤独，那我也加入开源的世界吧。搭建自己的博客，分享自己在工作中的问题，这本身不就是一件快乐的事情么？从有想法到实现，辛辛苦苦花费了将近一周的时间，终于把博客搭建了起来，中间的辛苦和快乐也只有自己最清楚。&lt;/p&gt;

&lt;p&gt;大概步骤记录下来&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;搭建ruby环境，搭建python环境，搭建jekyll环境&lt;/li&gt;
&lt;li&gt;找模板，改模板（最辛苦的一件事）&lt;/li&gt;
&lt;li&gt;添加统计，评论等小功能&lt;/li&gt;
&lt;li&gt;发布到github&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;中途碰到了无数问题，只能自己解决，百度不行google，google不行，那就想别的办法，反正最后终于搞成了如今的样子，还有一些bug，慢慢在解决吧，重点应该是内容而不是界面。&lt;/p&gt;

&lt;hr /&gt;
</content>
        <summary type="html">&lt;hr /&gt;

&lt;h2&gt;历程&lt;/h2&gt;

&lt;p&gt;一直以来我都是只写笔记不写博客，总以为写博客很无聊。直到后来接触到了github，接触到了开源，我才发现了分享的乐趣，我想我的那些笔记一定也不喜欢孤独，那我也加入开源的世界吧。搭建自己的博客，分享自己在工作中的问题，这本身不就是一件快乐的事情么？从有想法到实现，辛辛苦苦花费了将近一周的时间，终于把博客搭建了起来，中间的辛苦和快乐也只有自己最清楚。&lt;/p&gt;

&lt;p&gt;大概步骤记录下来&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;搭建ruby环境，搭建python环境，搭建jekyll环境&lt;/li&gt;
&lt;li&gt;找模板，改模板（最辛苦的一件事）&lt;/li&gt;
&lt;li&gt;添加统计，评论等小功能&lt;/li&gt;
&lt;li&gt;发布到github&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;中途碰到了无数问题，只能自己解决，百度不行google，google不行，那就想别的办法，反正最后终于搞成了如今的样子，还有一些bug，慢慢在解决吧，重点应该是内容而不是界面。&lt;/p&gt;

&lt;hr /&gt;
</summary>
    </entry>
    

</feed>